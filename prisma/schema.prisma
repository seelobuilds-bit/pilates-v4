generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  HQ_ADMIN
  OWNER
  TEACHER
}

model User {
  id        String   @id @default(cuid())
  email     String   @unique
  password  String
  firstName String
  lastName  String
  role      Role     @default(OWNER)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  ownedStudio Studio?
  teacher     Teacher?
}

model Studio {
  id           String   @id @default(cuid())
  name         String
  subdomain    String   @unique
  primaryColor String?  @default("#7c3aed")
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  ownerId String @unique
  owner   User   @relation(fields: [ownerId], references: [id])

  // Stripe Connect settings
  stripeAccountId       String?   @unique
  stripeOnboardingComplete Boolean @default(false)
  stripeChargesEnabled  Boolean   @default(false)
  stripePayoutsEnabled  Boolean   @default(false)
  stripeDetailsSubmitted Boolean  @default(false)
  stripeCurrency        String?   @default("usd")

  locations     Location[]
  classTypes    ClassType[]
  teachers      Teacher[]
  clients       Client[]
  classSessions ClassSession[]
  bookings      Booking[]
  payments      Payment[]
  
  // Communication settings
  emailConfig   StudioEmailConfig?
  smsConfig     StudioSmsConfig?
  messages      Message[]
  campaigns     Campaign[]
  automations   Automation[]
  segments      Segment[]
  templates     MessageTemplate[]
  systemEmails  SystemEmailTemplate[]
  
  // Website Analytics
  websiteConfig   WebsiteAnalyticsConfig?
  websiteEvents   WebsiteEvent[]
  websiteVisitors WebsiteVisitor[]
  
  // Teacher Invoices
  teacherInvoices TeacherInvoice[]
  
  // Class Flows & Training
  classFlowProgress ClassFlowProgress[]
  trainingRequests  TrainingRequest[]
}

// Email configuration per studio
model StudioEmailConfig {
  id                String   @id @default(cuid())
  provider          String   @default("sendgrid") // sendgrid, mailgun, ses, smtp
  apiKey            String?  // encrypted
  fromEmail         String   // sender email address
  fromName          String   // sender display name
  replyToEmail      String?  // reply-to address
  
  // SMTP settings (if provider is smtp)
  smtpHost          String?
  smtpPort          Int?
  smtpUser          String?
  smtpPassword      String?  // encrypted
  smtpSecure        Boolean  @default(true)
  
  // Verification status
  isVerified        Boolean  @default(false)
  verifiedAt        DateTime?
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  studioId String @unique
  studio   Studio @relation(fields: [studioId], references: [id], onDelete: Cascade)
}

// SMS configuration per studio
model StudioSmsConfig {
  id                String   @id @default(cuid())
  provider          String   @default("twilio") // twilio, messagebird, vonage
  accountSid        String?  // encrypted
  authToken         String?  // encrypted
  fromNumber        String   // sender phone number
  
  // Verification status
  isVerified        Boolean  @default(false)
  verifiedAt        DateTime?
  
  // Usage limits
  monthlyLimit      Int      @default(1000)
  currentMonthUsage Int      @default(0)
  
  createdAt         DateTime @default(now())
  updatedAt         DateTime @updatedAt

  studioId String @unique
  studio   Studio @relation(fields: [studioId], references: [id], onDelete: Cascade)
}

// Message types
enum MessageChannel {
  EMAIL
  SMS
}

enum MessageDirection {
  INBOUND
  OUTBOUND
}

enum MessageStatus {
  DRAFT
  QUEUED
  SENT
  DELIVERED
  FAILED
  BOUNCED
  OPENED
  CLICKED
}

// All messages (inbox conversations)
model Message {
  id            String           @id @default(cuid())
  channel       MessageChannel
  direction     MessageDirection
  status        MessageStatus    @default(QUEUED)
  
  // Content
  subject       String?          // for emails
  body          String           @db.Text
  htmlBody      String?          @db.Text // for emails
  
  // Sender/Recipient
  fromAddress   String           // email or phone
  toAddress     String           // email or phone
  fromName      String?
  toName        String?
  
  // Tracking
  sentAt        DateTime?
  deliveredAt   DateTime?
  openedAt      DateTime?
  clickedAt     DateTime?
  failedReason  String?
  
  // External IDs (from email/sms provider)
  externalId    String?
  
  createdAt     DateTime         @default(now())
  updatedAt     DateTime         @updatedAt

  studioId      String
  studio        Studio           @relation(fields: [studioId], references: [id], onDelete: Cascade)
  
  clientId      String?
  client        Client?          @relation(fields: [clientId], references: [id])
  
  // Link to campaign if sent via marketing
  campaignId    String?
  campaign      Campaign?        @relation(fields: [campaignId], references: [id])
  
  automationId  String?
  automation    Automation?      @relation(fields: [automationId], references: [id])

  @@index([studioId, clientId])
  @@index([studioId, createdAt])
}

// Marketing Campaigns
enum CampaignStatus {
  DRAFT
  SCHEDULED
  SENDING
  SENT
  PAUSED
  CANCELLED
}

model Campaign {
  id            String         @id @default(cuid())
  name          String
  channel       MessageChannel
  status        CampaignStatus @default(DRAFT)
  
  // Content
  subject       String?        // for emails
  body          String         @db.Text
  htmlBody      String?        @db.Text
  
  // Scheduling
  scheduledAt   DateTime?
  sentAt        DateTime?
  
  // Targeting
  targetAll     Boolean        @default(false)
  
  // Stats
  totalRecipients Int          @default(0)
  sentCount       Int          @default(0)
  deliveredCount  Int          @default(0)
  openedCount     Int          @default(0)
  clickedCount    Int          @default(0)
  failedCount     Int          @default(0)
  
  createdAt     DateTime       @default(now())
  updatedAt     DateTime       @updatedAt

  studioId      String
  studio        Studio         @relation(fields: [studioId], references: [id], onDelete: Cascade)
  
  // Target segment (optional)
  segmentId     String?
  segment       Segment?       @relation(fields: [segmentId], references: [id])
  
  // Target location (optional)
  locationId    String?
  location      Location?      @relation(fields: [locationId], references: [id])
  
  // Template used (optional)
  templateId    String?
  template      MessageTemplate? @relation(fields: [templateId], references: [id])
  
  messages      Message[]

  @@index([studioId, status])
}

// Marketing Automations
enum AutomationStatus {
  DRAFT
  ACTIVE
  PAUSED
  ARCHIVED
}

enum AutomationTrigger {
  WELCOME           // New client signup
  CLASS_REMINDER    // Before class
  CLASS_FOLLOWUP    // After class
  BOOKING_CONFIRMED // When booking is made
  BOOKING_CANCELLED // When booking is cancelled
  CLIENT_INACTIVE   // Client hasn't booked in X days
  BIRTHDAY          // Client birthday
  MEMBERSHIP_EXPIRING // Membership about to expire
}

model Automation {
  id            String            @id @default(cuid())
  name          String
  trigger       AutomationTrigger
  channel       MessageChannel
  status        AutomationStatus  @default(DRAFT)
  
  // Content
  subject       String?           // for emails
  body          String            @db.Text
  htmlBody      String?           @db.Text
  
  // Trigger settings
  triggerDelay  Int               @default(0) // minutes before/after trigger
  triggerDays   Int?              // for CLIENT_INACTIVE - days of inactivity
  reminderHours Int?              // for CLASS_REMINDER - hours before class
  
  // Stats
  totalSent     Int               @default(0)
  totalDelivered Int              @default(0)
  totalOpened   Int               @default(0)
  totalClicked  Int               @default(0)
  
  createdAt     DateTime          @default(now())
  updatedAt     DateTime          @updatedAt

  studioId      String
  studio        Studio            @relation(fields: [studioId], references: [id], onDelete: Cascade)
  
  // Target location (optional - all if not set)
  locationId    String?
  location      Location?         @relation(fields: [locationId], references: [id])
  
  // Template used (optional)
  templateId    String?
  template      MessageTemplate?  @relation(fields: [templateId], references: [id])
  
  messages      Message[]

  @@index([studioId, status, trigger])
}

// Client Segments for targeting
model Segment {
  id            String    @id @default(cuid())
  name          String
  description   String?
  
  // Filter rules (JSON structure)
  rules         String    @db.Text // JSON: { "conditions": [...], "operator": "AND" }
  
  // Cached count
  clientCount   Int       @default(0)
  lastCalculated DateTime?
  
  createdAt     DateTime  @default(now())
  updatedAt     DateTime  @updatedAt

  studioId      String
  studio        Studio    @relation(fields: [studioId], references: [id], onDelete: Cascade)
  
  campaigns     Campaign[]

  @@index([studioId])
}

// Message Templates
enum TemplateType {
  EMAIL
  SMS
}

model MessageTemplate {
  id            String       @id @default(cuid())
  name          String
  type          TemplateType
  
  // Content
  subject       String?      // for emails
  body          String       @db.Text
  htmlBody      String?      @db.Text
  
  // Variables available (e.g., {{firstName}}, {{className}})
  variables     String[]
  
  createdAt     DateTime     @default(now())
  updatedAt     DateTime     @updatedAt

  studioId      String
  studio        Studio       @relation(fields: [studioId], references: [id], onDelete: Cascade)
  
  campaigns     Campaign[]
  automations   Automation[]

  @@index([studioId, type])
}

// System Email Templates (transactional emails)
enum SystemEmailType {
  BOOKING_CONFIRMATION       // When a client books a class
  CLASS_CANCELLED_BY_STUDIO  // When studio cancels a class
  CLASS_CANCELLED_BY_CLIENT  // When client cancels their booking
  PAYMENT_SUCCESS            // When payment/rebill succeeds
  PAYMENT_FAILED             // When payment/rebill fails
  PAYMENT_REFUND             // When a refund is processed
  PASSWORD_RESET             // Forgotten password email
  WELCOME                    // Welcome email for new clients
}

model SystemEmailTemplate {
  id            String          @id @default(cuid())
  type          SystemEmailType @unique
  name          String          // Display name for the template
  subject       String          // Email subject line
  body          String          @db.Text // Plain text version
  htmlBody      String          @db.Text // HTML version
  isEnabled     Boolean         @default(true)
  
  // Available variables for this template type
  variables     String[]
  
  createdAt     DateTime        @default(now())
  updatedAt     DateTime        @updatedAt

  studioId      String
  studio        Studio          @relation(fields: [studioId], references: [id], onDelete: Cascade)

  @@unique([studioId, type])
  @@index([studioId])
}

model Location {
  id        String   @id @default(cuid())
  name      String
  address   String
  city      String
  state     String
  zipCode   String
  phone     String?
  isActive  Boolean  @default(true)
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  studioId String
  studio   Studio @relation(fields: [studioId], references: [id], onDelete: Cascade)

  classSessions ClassSession[]
  campaigns     Campaign[]
  automations   Automation[]
}

model ClassType {
  id          String   @id @default(cuid())
  name        String
  description String?
  duration    Int      @default(60)
  capacity    Int      @default(10)
  price       Float
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  studioId String
  studio   Studio @relation(fields: [studioId], references: [id], onDelete: Cascade)

  classSessions ClassSession[]
}

model Teacher {
  id          String   @id @default(cuid())
  bio         String?
  specialties String[]
  isActive    Boolean  @default(true)
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  userId String @unique
  user   User   @relation(fields: [userId], references: [id])

  studioId String
  studio   Studio @relation(fields: [studioId], references: [id], onDelete: Cascade)

  classSessions     ClassSession[]
  blockedTimes      TeacherBlockedTime[]
  payRate           TeacherPayRate?
  invoices          TeacherInvoice[]
  classFlowProgress ClassFlowProgress[]
  trainingRequests  TrainingRequest[]
}

// Teacher blocked/unavailable times
model TeacherBlockedTime {
  id          String   @id @default(cuid())
  startTime   DateTime
  endTime     DateTime
  reason      String?  // Optional reason (e.g., "Vacation", "Personal", "Training")
  isRecurring Boolean  @default(false)
  recurringDays Int[]  // Day of week (0-6) if recurring
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  teacherId String
  teacher   Teacher @relation(fields: [teacherId], references: [id], onDelete: Cascade)

  @@index([teacherId, startTime, endTime])
}

// Teacher pay rate configuration
enum PayRateType {
  PER_CLASS     // Fixed amount per class taught
  PER_HOUR      // Hourly rate
  PER_STUDENT   // Amount per student that attends
  PERCENTAGE    // Percentage of class revenue
}

model TeacherPayRate {
  id            String      @id @default(cuid())
  type          PayRateType @default(PER_CLASS)
  rate          Float       // Amount in currency
  currency      String      @default("USD")
  
  // Optional overrides per class type
  classTypeRates String?    @db.Text // JSON: { classTypeId: rate }
  
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt

  teacherId     String      @unique
  teacher       Teacher     @relation(fields: [teacherId], references: [id], onDelete: Cascade)
}

// Teacher invoice status
enum InvoiceStatus {
  DRAFT
  PENDING
  SENT
  PAID
  CANCELLED
}

model TeacherInvoice {
  id              String        @id @default(cuid())
  invoiceNumber   String        // e.g., INV-2024-001
  status          InvoiceStatus @default(DRAFT)
  
  // Period covered
  periodStart     DateTime
  periodEnd       DateTime
  
  // Line items stored as JSON
  lineItems       String        @db.Text // JSON array of { description, classId?, quantity, rate, amount }
  
  // Totals
  subtotal        Float
  tax             Float         @default(0)
  taxRate         Float         @default(0)
  total           Float
  
  // Payment info
  currency        String        @default("USD")
  notes           String?       @db.Text
  
  // Sent/Paid tracking
  sentAt          DateTime?
  paidAt          DateTime?
  paidAmount      Float?
  paymentMethod   String?
  paymentReference String?
  
  createdAt       DateTime      @default(now())
  updatedAt       DateTime      @updatedAt

  teacherId       String
  teacher         Teacher       @relation(fields: [teacherId], references: [id], onDelete: Cascade)
  
  studioId        String
  studio          Studio        @relation(fields: [studioId], references: [id], onDelete: Cascade)

  @@index([teacherId, periodStart])
  @@index([studioId, invoiceNumber])
}

model Client {
  id                  String   @id @default(cuid())
  email               String
  password            String?
  firstName           String
  lastName            String
  phone               String?
  birthday            DateTime?
  isActive            Boolean  @default(true)
  credits             Int      @default(0)
  stripeCustomerId    String?  // Stripe customer ID for this client at this studio
  createdAt           DateTime @default(now())
  updatedAt           DateTime @updatedAt

  studioId String
  studio   Studio @relation(fields: [studioId], references: [id], onDelete: Cascade)

  bookings Booking[]
  messages Message[]
  payments Payment[]

  @@unique([email, studioId])
}

model ClassSession {
  id        String   @id @default(cuid())
  startTime DateTime
  endTime   DateTime
  capacity  Int
  notes     String?
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  studioId    String
  studio      Studio    @relation(fields: [studioId], references: [id], onDelete: Cascade)
  classTypeId String
  classType   ClassType @relation(fields: [classTypeId], references: [id])
  teacherId   String
  teacher     Teacher   @relation(fields: [teacherId], references: [id])
  locationId  String
  location    Location  @relation(fields: [locationId], references: [id])

  bookings Booking[]
}

enum BookingStatus {
  PENDING
  CONFIRMED
  CANCELLED
  COMPLETED
  NO_SHOW
}

model Booking {
  id         String        @id @default(cuid())
  status     BookingStatus @default(PENDING)
  paidAmount Float?
  notes      String?
  createdAt  DateTime      @default(now())
  updatedAt  DateTime      @updatedAt

  studioId       String
  studio         Studio       @relation(fields: [studioId], references: [id], onDelete: Cascade)
  clientId       String
  client         Client       @relation(fields: [clientId], references: [id])
  classSessionId String
  classSession   ClassSession @relation(fields: [classSessionId], references: [id])
  
  // Payment
  paymentId      String?
  payment        Payment?     @relation(fields: [paymentId], references: [id])
}

// Payment tracking
enum PaymentStatus {
  PENDING
  PROCESSING
  SUCCEEDED
  FAILED
  REFUNDED
  PARTIALLY_REFUNDED
}

model Payment {
  id                    String        @id @default(cuid())
  amount                Float         // Amount in cents
  currency              String        @default("usd")
  status                PaymentStatus @default(PENDING)
  
  // Stripe IDs
  stripePaymentIntentId String?       @unique
  stripeChargeId        String?
  stripeRefundId        String?
  
  // For checkout sessions
  stripeCheckoutSessionId String?     @unique
  
  // Fees
  stripeFee             Float?        // Stripe's fee
  applicationFee        Float?        // Our platform fee (if any)
  netAmount             Float?        // Amount after fees
  
  // Metadata
  description           String?
  receiptUrl            String?
  failureMessage        String?
  
  // Refund tracking
  refundedAmount        Float?
  refundedAt            DateTime?
  
  createdAt             DateTime      @default(now())
  updatedAt             DateTime      @updatedAt

  studioId              String
  studio                Studio        @relation(fields: [studioId], references: [id], onDelete: Cascade)
  
  clientId              String
  client                Client        @relation(fields: [clientId], references: [id])
  
  bookings              Booking[]

  @@index([studioId, createdAt])
  @@index([stripePaymentIntentId])
}

// Website Analytics Configuration
model WebsiteAnalyticsConfig {
  id              String   @id @default(cuid())
  trackingId      String   @unique @default(cuid()) // Unique ID for the tracking script
  websiteUrl      String?  // Main website URL
  platform        String?  // wordpress, wix, shopify, squarespace, custom, etc.
  isEnabled       Boolean  @default(true)
  
  // Tracking settings
  trackPageViews  Boolean  @default(true)
  trackClicks     Boolean  @default(true)
  trackForms      Boolean  @default(true)
  trackScrollDepth Boolean @default(false)
  trackOutboundLinks Boolean @default(true)
  
  // Conversion tracking
  conversionGoals String?  @db.Text // JSON array of conversion goals
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  studioId        String   @unique
  studio          Studio   @relation(fields: [studioId], references: [id], onDelete: Cascade)
}

// Website Visitors (unique visitors)
model WebsiteVisitor {
  id              String   @id @default(cuid())
  visitorId       String   // Anonymous visitor ID (stored in cookie)
  
  // Visitor info
  firstVisit      DateTime @default(now())
  lastVisit       DateTime @default(now())
  totalVisits     Int      @default(1)
  totalPageViews  Int      @default(0)
  
  // Device/Browser info
  userAgent       String?
  browser         String?
  os              String?
  device          String?  // desktop, mobile, tablet
  
  // Location (from IP)
  country         String?
  city            String?
  
  // Source attribution
  firstSource     String?  // Where they first came from
  firstMedium     String?  // organic, paid, referral, direct, social
  firstCampaign   String?  // UTM campaign
  
  // Conversion status
  hasConverted    Boolean  @default(false)
  convertedAt     DateTime?
  
  // Link to client if they become one
  clientId        String?
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  studioId        String
  studio          Studio   @relation(fields: [studioId], references: [id], onDelete: Cascade)
  
  events          WebsiteEvent[]

  @@unique([studioId, visitorId])
  @@index([studioId, lastVisit])
  @@index([studioId, hasConverted])
}

// Website Events (page views, clicks, conversions, etc.)
enum WebsiteEventType {
  PAGE_VIEW
  CLICK
  FORM_SUBMIT
  SCROLL_DEPTH
  OUTBOUND_LINK
  CONVERSION
  CUSTOM
}

model WebsiteEvent {
  id              String           @id @default(cuid())
  type            WebsiteEventType
  
  // Page info
  pageUrl         String
  pageTitle       String?
  pagePath        String?
  
  // Event details
  eventName       String?          // For custom events
  eventData       String?          @db.Text // JSON data
  
  // Click tracking
  elementId       String?
  elementClass    String?
  elementText     String?
  
  // Scroll depth
  scrollDepth     Int?             // Percentage 0-100
  
  // Referrer
  referrer        String?
  
  // UTM parameters
  utmSource       String?
  utmMedium       String?
  utmCampaign     String?
  utmTerm         String?
  utmContent      String?
  
  // Session info
  sessionId       String?
  
  createdAt       DateTime         @default(now())

  studioId        String
  studio          Studio           @relation(fields: [studioId], references: [id], onDelete: Cascade)
  
  visitorId       String?
  visitor         WebsiteVisitor?  @relation(fields: [visitorId], references: [id])

  @@index([studioId, createdAt])
  @@index([studioId, type])
  @@index([studioId, pagePath])
}

// ==========================================
// CLASS FLOWS & TRAINING CONTENT
// ==========================================

// Class flow categories (Reformer, Mat, Tower, etc.)
model ClassFlowCategory {
  id          String   @id @default(cuid())
  name        String
  description String?
  icon        String?  // Icon name or emoji
  color       String?  // Hex color for styling
  order       Int      @default(0)
  isActive    Boolean  @default(true)
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  contents    ClassFlowContent[]
}

// Content types
enum ContentType {
  VIDEO
  PDF
  ARTICLE
  QUIZ
}

// Difficulty levels
enum DifficultyLevel {
  BEGINNER
  INTERMEDIATE
  ADVANCED
  EXPERT
}

// Individual class flow content items
model ClassFlowContent {
  id              String          @id @default(cuid())
  title           String
  description     String?         @db.Text
  type            ContentType
  difficulty      DifficultyLevel @default(BEGINNER)
  
  // Content URLs
  videoUrl        String?         // YouTube, Vimeo, or hosted video URL
  thumbnailUrl    String?         // Preview image
  pdfUrl          String?         // PDF file URL
  articleContent  String?         @db.Text // Rich text content for articles
  
  // Duration in minutes (for videos)
  duration        Int?
  
  // Ordering and status
  order           Int             @default(0)
  isPublished     Boolean         @default(true)
  isFeatured      Boolean         @default(false)
  
  // Metadata
  tags            String[]
  
  createdAt       DateTime        @default(now())
  updatedAt       DateTime        @updatedAt

  categoryId      String
  category        ClassFlowCategory @relation(fields: [categoryId], references: [id], onDelete: Cascade)

  progress        ClassFlowProgress[]

  @@index([categoryId])
  @@index([type])
  @@index([difficulty])
}

// Track teacher progress on class flows
model ClassFlowProgress {
  id              String   @id @default(cuid())
  
  // Progress tracking
  isCompleted     Boolean  @default(false)
  completedAt     DateTime?
  lastViewedAt    DateTime @default(now())
  progressPercent Int      @default(0) // 0-100 for videos
  notes           String?  @db.Text    // Teacher's personal notes
  
  createdAt       DateTime @default(now())
  updatedAt       DateTime @updatedAt

  contentId       String
  content         ClassFlowContent @relation(fields: [contentId], references: [id], onDelete: Cascade)
  
  teacherId       String
  teacher         Teacher  @relation(fields: [teacherId], references: [id], onDelete: Cascade)
  
  studioId        String
  studio          Studio   @relation(fields: [studioId], references: [id], onDelete: Cascade)

  @@unique([contentId, teacherId])
  @@index([teacherId])
  @@index([studioId])
}

// Training request status
enum TrainingRequestStatus {
  PENDING
  APPROVED
  SCHEDULED
  COMPLETED
  CANCELLED
}

// On-site training requests
model TrainingRequest {
  id              String                @id @default(cuid())
  
  // Request details
  title           String
  description     String                @db.Text
  trainingType    String                // "reformer-advanced", "mat-certification", etc.
  
  // Preferred dates
  preferredDate1  DateTime?
  preferredDate2  DateTime?
  preferredDate3  DateTime?
  
  // Scheduling
  scheduledDate   DateTime?
  scheduledTime   String?               // e.g., "9:00 AM - 5:00 PM"
  
  // Status tracking
  status          TrainingRequestStatus @default(PENDING)
  
  // Contact info
  contactName     String
  contactEmail    String
  contactPhone    String?
  
  // Location (where training will be held)
  location        String?
  address         String?               @db.Text
  
  // Number of attendees
  attendeeCount   Int                   @default(1)
  
  // Notes
  notes           String?               @db.Text
  adminNotes      String?               @db.Text // Internal notes
  
  // Pricing (if applicable)
  estimatedCost   Float?
  finalCost       Float?
  
  createdAt       DateTime              @default(now())
  updatedAt       DateTime              @updatedAt

  studioId        String
  studio          Studio                @relation(fields: [studioId], references: [id], onDelete: Cascade)
  
  requestedById   String
  requestedBy     Teacher               @relation(fields: [requestedById], references: [id])

  @@index([studioId, status])
  @@index([status])
}
